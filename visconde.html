<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Visconde</title>
<link href="visconde.css" type="text/css" rel="stylesheet">
</head><body>
<h1>Basic literate tool in python</h1>

<h2>Introduction</h2>

<p>This is a rough tool for literate programming, built along the lines
of the CWEB program of <a href="https://cs.stanford.edu/~knuth/lp.html">Knuth and Levy</a>.
Our syntax follows that of <a href="https://github.com/zyedidia/Literate/">Literate</a>.
We only implement a subset of these programs' functionality.</p>

<p>(A manual of visconde can  be found on the project&rsquo;s <a href="https://github.com/tnaia/visconde/">Github
repository</a>.)</p>

<p>More precisely, this program is a minimal &ldquo;tangler/weaver&rdquo; which
operates on a single input file, under the restriction that any chunk
reference, (say, <code>@{chunk name}</code>) lies on a line of its own (this
means, in particular, that not even comments are allowed in a line
that references a chunk; a chunk name also cannot contain line
breaks).</p>

<p>The line below should be updated whenever this program is changed.</p>

<div class="codeblock"><span class="codeblock_name"><a id="1">1</a> {<strong>global definitions</strong> <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
banner = "This is VISCONDE version 0.1.6."
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>Here is the program outline.</p>

<div class="codeblock"><span class="codeblock_name"><a id="2">2</a> {<strong>visconde.py</strong>}</span>

<pre class="prettyprint language-python">
<code class="chunk_ref">@{imports}</code>
<code class="chunk_ref">@{global definitions}</code>

<code class="chunk_ref">@{parse arguments}</code>

print(banner) # Hi!

<code class="chunk_ref">@{process input file}</code>
<code class="chunk_ref">@{output tangled sources}</code>
<code class="chunk_ref">@{output weaved file}</code>
</pre></div>


<h2>Arguments</h2>

<p>The main argument is the path to the literate source file. Arguments
are parsed as usual in most command line applications, so a typical
call to <code>visconde</code> would look like this</p>

<pre><code>python3 visconde.py [OPTIONS] INPUT_FILE
</code></pre>

<p>Where <code>OPTIONS</code> can be one or more of the following.</p>

<ul>
<li><code>--fencedwithlanguage</code> first word (at the same line but) after opening fence treated as language of the code chunk</li>
<li><code>--nofencedwithlanguage</code> text (at same line but) after opening fence treated as chunk name (default)</li>
<li><code>--manyoutputs</code> generate one output file per root chunk</li>
<li><code>--nomanyoutputs</code> error (and no output files) if more than one root chunk (default)</li>
<li><code>--tangle</code> produce tangled outputs (default)</li>
<li><code>--notangle</code> do not produce tangled outputs</li>
<li><code>--weave</code> produce weaved output</li>
<li><code>--noweave</code> do not produce weaved outputs (default)</li>
<li><code>--markdownsections</code> use markdown headings (lines starting by up to six <code>#</code> characters) as section divisions (default, and currently only option)</li>
<li><code>--index</code> produce word index (default)</li>
<li><code>--noindex</code> no word index</li>
</ul>


<div class="codeblock"><span class="codeblock_name"><a id="3">3</a> {<strong>parse arguments</strong>}</span>

<pre class="prettyprint language-python">
<code class="chunk_ref">@{build argument parser}</code>
<code class="chunk_ref">@{set flags}</code>
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>All flags appear in pairs.</p>

<div class="codeblock"><span class="codeblock_name"><a id="4">4</a> {<strong>build argument parser</strong>}</span>

<pre class="prettyprint language-python">
# file =================================================================
parser.add_argument("file", help="literate source file")

# fencedwithlanguage ===================================================
parser.add_argument(  "--fencedwithlanguage", action="store_true", 
    help="first word on opening fence is language; the rest is chunk name")
parser.add_argument("--nofencedwithlanguage", action="store_true", 
    help="text on opening fence is chunk name (default)")

# manyoutputs ==========================================================
parser.add_argument(         "--manyoutputs", action="store_true", 
    help="generate one output file per root chunk")
parser.add_argument(       "--nomanyoutputs", action="store_true", 
    help="generate one output file per root chunk (default)")

# tangle ===============================================================
parser.add_argument(              "--tangle", action="store_true", 
    help="produce tangled outputs (default)")
parser.add_argument(            "--notangle", action="store_true", 
    help="do not produce tangled outputs")

# weave ================================================================
parser.add_argument(  "--weave", action="store_true", 
    help="produce weaved output")
parser.add_argument("--noweave", action="store_true", 
    help="do not produce weaved output (default)")

# index ================================================================
parser.add_argument(               "--index", action="store_true",
    help="produce word index (default)")
parser.add_argument(             "--noindex", action="store_true",
    help="do not produce word index")


# ======================================================================
args = parser.parse_args()
</pre><span class="usedin">Used in <a href="#3">3</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="5">5</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
parser = argparse.ArgumentParser()
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="6">6</a> {<strong>imports</strong> <a href="#13">13</a>}</span>

<pre class="prettyprint language-python">
import argparse
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>It is time to enforce the default behaviour for each pair of flags
<code>--xxx</code>/<code>--noxxx</code>, and check for sanity.</p>

<div class="codeblock"><span class="codeblock_name"><a id="7">7</a> {<strong>set flags</strong>}</span>

<pre class="prettyprint language-python">
# input file ===========================================================
file = args.file


# flag (no)fencedwithlanguage ==========================================
if args.fencedwithlanguage and args.nofencedwithlanguage:
    raise SystemExit('! error: contradictory flags (fencedwithlanguage and nofencedwithlanguage)')

fenced_with_language = args.fencedwithlanguage


# flag (no)manyoutputs =================================================
if args.manyoutputs and args.nomanyoutputs:
    raise SystemExit('! error: contradictory flags (manyoutputs and nomanyoutputs)')

many_outpus = args.manyoutputs


# flag (no)tangle ======================================================
if args.tangle and args.notangle:
    raise SystemExit('! error: contradictory flags (tangle and notangle)')

tangle = not args.notangle

# flag (no)weave =======================================================
if args.weave and args.noweave:
    raise SystemExit('! error: contradictory flags (weave and noweave)')

weave = args.weave

# flag (no)index =======================================================
if args.index and args.noindex:
    raise SystemExit('! error: contradictory flags (index and noindex)')

index = not args.noindex
</pre><span class="usedin">Used in <a href="#3">3</a>.</span></div>


<p>The flags are available to the rest of the program via the global
variables <code>file</code>, <code>fenced_with_language</code> and <code>tangle</code>.</p>

<div class="codeblock"><span class="codeblock_name"><a id="8">8</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
file = ""

fenced_with_language = False
many_outpus = False
tangle = True
index = True
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<h2>Storing chunks</h2>

<p>Visconde sees the input file as a series of lines which are either
text (natural language prose), code (to be tangled) or a fence
(boundary between the two). Each occurence of code surrounded by
fences forms a <strong>block</strong> (or code block); the (ordered) collection of code
blocks with same name forms a <strong>chunk</strong>.</p>

<div class="codeblock"><span class="codeblock_name"><a id="9">9</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
class Chunk:
    '''Collection of blocks with same name'''
    
    def __init__(self):
        self.blocks = []
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>Blocks are all numbered. Each block stores</p>

<ul>
<li>the line number (of the input file) of the first line of the block, and</li>
<li>the lines of code in the block.</li>
</ul>


<div class="codeblock"><span class="codeblock_name"><a id="10">10</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
class Block:
    '''Lines of a block of code.'''
    block_counter = 0
    
    def __init__(self,line_number,block_lines):
        self.start = line_number
        self.lines = block_lines
        Block.block_counter +=1
        self.id = Block.block_counter
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>In this first pass over the input
file, we only care about the two latter cases.</p>

<p>We read text lines until we reach a fence (start of a code chunk). Next we store
the chunk name and accumulate the lines of the chunk in a list <code>chunk_text</code>,
which is finally stored at the point when we reach the fence ending the chunk.</p>

<div class="codeblock"><span class="codeblock_name"><a id="11">11</a> {<strong>process input file</strong>}</span>

<pre class="prettyprint language-python">
with open(file, 'r') as input_file:
    reading_code_chunk = False
    last_line_blank = False
    chunk_name = ''
    block_lines = [] # list of lines

    for line_number, line in enumerate(input_file):
        <code class="chunk_ref">@{continue if not in code block; set `chunk_name` and `reading_code_chunk`}</code>
    
        <code class="chunk_ref">@{add line to `block_lines` or complete and store chunk}</code>
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>Every code chunk is preceded by a blank line (i.e., a line with only white space).
The first line of a code chunk begins with three or more backticks (<code>```</code>),
followed by the chunk name. The last line of a code chunk contains only backticks,
(as many as there were at the chunk&rsquo;s first line).</p>

<div class="codeblock"><span class="codeblock_name"><a id="12">12</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
fence_regexp = re.compile('```+')
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="13">13</a> {<strong>imports</strong> <a href="#6">6</a>}</span>

<pre class="prettyprint language-python">
import re
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>Note that if <code>reading_code_chunk</code> is <code>False</code>, then we will eventually
reach a <code>continue</code> instruction; and, hence, <code>@{add line to
`block_lines`...}</code> is only reached when <code>reading_code_chunk == True</code>.</p>

<div class="codeblock"><span class="codeblock_name"><a id="14">14</a> {<strong>continue if not in code block; set `chunk_name` and `reading_code_chunk`</strong>}</span>

<pre class="prettyprint language-python">
if not reading_code_chunk:
    if line.strip() == "":
        last_line_blank = True
        continue
    elif last_line_blank:
        match_fence = fence_regexp.match(line)
        if match_fence:
            fence_length = match_fence.end()
            <code class="chunk_ref">@{set `chunk_name`}</code>
            chunk_line = line_number
            block_lines = []
            reading_code_chunk = True
        else:
            last_line_blank = False

    continue
</pre><span class="usedin">Used in <a href="#11">11</a>.</span></div>


<p>The chunk name is a stripped substring of the opening fence. If chunks
do not have a language specification, then the chunk name is the
(space-stripped) substring of line which goes from the last backtick
of the fence until the end of the line; otherwise, it goes from the
first space character and goes until the end of the line (we do this
so that the fence can be followed immediately by a language
specification).</p>

<div class="codeblock"><span class="codeblock_name"><a id="15">15</a> {<strong>set `chunk_name`</strong>}</span>

<pre class="prettyprint language-python">
j = fence_length
if fenced_with_language:
    while line[j] == ' ':
        j += 1
    while line[j] != ' ':
        j += 1
chunk_name = line[j+1:].strip()
</pre><span class="usedin">Used in <a href="#14">14</a>.</span></div>


<p>We store the code block of chunk named <code>chunk_name</code> in the dictionary <code>chunk</code>.
Each dictionary entry is a chunk object, containing a list of the code blocks of the same name.</p>

<div class="codeblock"><span class="codeblock_name"><a id="16">16</a> {<strong>add line to `block_lines` or complete and store chunk</strong>}</span>

<pre class="prettyprint language-python">
match_fence = fence_regexp.match(line)
if match_fence and match_fence.end() == fence_length:
    if chunk_name not in chunk:
        chunk[chunk_name] = Chunk()
    new_block = Block(chunk_line+1, block_lines)
    chunk[chunk_name].blocks += [new_block]
    block += [new_block]
    reading_code_chunk = False
    last_line_blank = False
else:
    block_lines += [line]
</pre><span class="usedin">Used in <a href="#11">11</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="17">17</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
chunk = {} # all chunks
block = [] # all code blocks
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<h2>From chunks to files</h2>

<p>When we are done reading the input file, all code chunks
are stored somewhere in the <code>chunk</code> dictionary, and it is
time to combine them and write the output files.</p>

<p>If chunk <code>'blabla'</code> is not referenced by any other chunk,
we shall create a file named <code>blabla</code> whose contents are
the lines in <code>chunk['blabla']</code>. Of course, we need to watch
out for chunk references (lines such as <code>@{xxx}</code>), which
will be replaced (recursively) by the correct content
(i.e., <code>chunk['xxx']</code>).</p>

<p>The first step is to identify which chunks are to become
files&mdash;we call these <em>root chunks</em>.</p>

<div class="codeblock"><span class="codeblock_name"><a id="18">18</a> {<strong>output tangled sources</strong>}</span>

<pre class="prettyprint language-python">
<code class="chunk_ref">@{build list of `root_chunks`}</code>

if tangle and (not many_outpus) and (len(root_chunks) > 1):
    <code class="chunk_ref">@{error: too many root chunks}</code>
else:
    for blk in root_chunks:
        <code class="chunk_ref">@{write `blk` to a file}</code>
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="19">19</a> {<strong>error: too many root chunks</strong>}</span>

<pre class="prettyprint language-python">
raise SystemExit('! error: too many root chunks\n  -----  chunk list:' + ','.join(root_chunks))
</pre><span class="usedin">Used in <a href="#18">18</a>.</span></div>


<p>The dictionary <code>used_at</code> stores a list of chunks which refer to any
given chunk, e.g.: <code>used_at['global definitions']</code> is a list of each
<code>chunk_name</code> containing <code>@{global definitions}</code> in its text (but read
on).</p>

<p>Well, actually, things are slightly more complicated: rather than a
list of chunk names, we actually store a list of pairs: an integer and
the chunk name. Recall that each chunk name is (potentially) related
to a series of code chunks; the integer is the index of the code
chunk. We shall use this in section <code>@{}</code>, to link each chunk to the
chunks where it is used.</p>

<div class="codeblock"><span class="codeblock_name"><a id="20">20</a> {<strong>build list of `root_chunks`</strong>}</span>

<pre class="prettyprint language-python">
used_at = dict()

for blk in chunk:
    if blk not in used_at:
        used_at[blk] = []
    for i,b in enumerate(chunk[blk].blocks):
        for chk in chunks_of(b.lines):
            if chk not in used_at:
                used_at[chk]  = [(blk, b.id, i)]
            else:
                used_at[chk] += [(blk, b.id, i)]

#print(used_at)
root_chunks = [blk for blk, parents in used_at.items() if len(parents) == 0]
<code class="chunk_ref">@{list root chunks}</code>
</pre><span class="usedin">Used in <a href="#18">18</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="21">21</a> {<strong>list root chunks</strong>}</span>

<pre class="prettyprint language-python">
if len(root_chunks) == 1:
    print("root chunk: '" + root_chunks[0] + "'")
elif len(root_chunks) > 1:
    print('root chunks: ' + ', '.join(["'" + c + "'" for c in root_chunks]))
else:
    print('! warning: I cannot find any  root chunk')
    #todo: it's alright if no tangle option was chosen
</pre><span class="usedin">Used in <a href="#20">20</a>.</span></div>


<p>We need to strip spaces surrounding chunk references, as well as
spaces surrounding the chunk name. If we write <code>␣</code> to denote a space
character, then, for each line of code which is a chunk reference (for
instance, <code>␣␣@{␣␣␣global␣definitions␣␣}␣␣</code>) we proceed as follows</p>

<ol>
<li>strip leading and trailing spaces (yields <code>@{␣␣␣global␣definitions␣␣}</code>),</li>
<li>remove <code>@{</code> and <code>}</code> (yields <code>␣␣␣global␣definitions␣␣</code>),</li>
<li>strip spaces again (yields <code>global␣definitions</code>).</li>
</ol>


<div class="codeblock"><span class="codeblock_name"><a id="22">22</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#27">27</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
def chunks_of(code):
    return [line.strip()[2:-1].strip() for line in code if is_chunk_line(line)]
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>We finally handle writing each root chunk to a file.
The next lines to be output are stored in a buffer. More precisely,
<code>buffer[i]</code> is the next line we&rsquo;ll output. The only exception to this
occurs when <code>buffer[i]</code> is a chunk reference. In this case we replace
<code>buffer[i]</code> by the lines corresponding to the appropriate chunk.
(Actually, we do something slightly different&mdash;look at the code.)</p>

<p>If we find a reference to chunk <code>c</code>, but <code>chunk[c]</code> is undefined, we
consider <code>chunk[c]</code> the reference, verbatim; we also issue a warning.</p>

<div class="codeblock"><span class="codeblock_name"><a id="23">23</a> {<strong>write `blk` to a file</strong>}</span>

<pre class="prettyprint language-python">
print("Writing file %s...    " % blk,end='')
with open(blk, 'w') as output:
    buffer = [l for b in chunk[blk].blocks for l in b.lines]
    i = 0
    while i < len(buffer):
        <code class="chunk_ref">@{output tangled line}</code>
        
print("[ DONE ]")
</pre><span class="usedin">Used in <a href="#18">18</a>.</span></div>


<p>Lines are either output verbatim or (if line is a valid chunk reference)
replaced by the corresponding chunk contents.</p>

<div class="codeblock"><span class="codeblock_name"><a id="24">24</a> {<strong>output tangled line</strong>}</span>

<pre class="prettyprint language-python">
if is_chunk_line(buffer[i]):
    chunk_name = chunk_line_name(buffer[i])
    if chunk_name not in chunk:
        <code class="chunk_ref">@{warn of undefined chunk}</code>

        print(buffer[i], file=output, end='') # insert reference verbatim
        i += 1
    else:
        <code class="chunk_ref">@{add contents of chunk to buffer}</code>
else:
    print(buffer[i], file=output, end='')
    i += 1
</pre><span class="usedin">Used in <a href="#23">23</a>.</span></div>


<p>We preserve the number of spaces before a reference, adding it as a
prefix to each line when inserting the contents of a chunk. (The way
we insert lines to buffer is wasteful because slicing <code>buffer</code> creates
a (shallow) copy of the sliced portion.)</p>

<div class="codeblock"><span class="codeblock_name"><a id="25">25</a> {<strong>add contents of chunk to buffer</strong>}</span>

<pre class="prettyprint language-python">
indent = re.compile(' *').match(buffer[i]).end()
ind_lns = [x for b in chunk[chunk_name].blocks for x in add_indent(indent, b.lines)]
buffer = ind_lns + buffer[i+1:]
i = 0
</pre><span class="usedin">Used in <a href="#24">24</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="26">26</a> {<strong>warn of undefined chunk</strong>}</span>

<pre class="prettyprint language-python">
print("! warning: undefined chunk; reference will be kept verbatim: %s" % chunk_name)
</pre><span class="usedin">Used in <a href="#24">24</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="27">27</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#37">37</a>}</span>

<pre class="prettyprint language-python">
def is_chunk_line(l):
    aux = l.strip()
    return aux and (aux[0:2] == '@{' and aux[-1] == '}')

def chunk_line_name(line):
    return line.strip()[2:-1].strip()

def add_indent(indent_amount, code):
    return [' '*indent_amount + line for line in code]
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<h2>Weaving, hacked</h2>

<p>Pseudo-weaving, that&rsquo;s more like it. We do tiny modifications to
the source file, so that (if it was properly written) it can be
passed through markdown. They fall in three categories:</p>

<ol>
<li>Add (optional) content wrapping the weaved output.</li>
<li>Remove chunk name from fenced line (place it in a <code>span</code> tag
preceding the code chunk).</li>
<li>Wrap the span above and the code in divs.</li>
</ol>


<div class="codeblock"><span class="codeblock_name"><a id="28">28</a> {<strong>output weaved file</strong>}</span>

<pre class="prettyprint language-python">
with open(file, 'r') as input_file:
    out_filename = file + '.md'
    print("Writing file %s... " % out_filename,end='')
    with open(out_filename, 'w') as output_file:
        <code class="chunk_ref">@{output html header}</code>
        <code class="chunk_ref">@{weave source}</code>
        <code class="chunk_ref">@{prepare and output word index}</code>
        <code class="chunk_ref">@{output html tail}</code>
    print("[ DONE ]")
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>We provide a mechanism for inserting stuff before (header) and after
(tail) the weaved output.</p>

<div class="codeblock"><span class="codeblock_name"><a id="29">29</a> {<strong>output html header</strong>}</span>

<pre class="prettyprint language-python">
html_header = ''

print(html_header, file=output_file, end='\n')
</pre><span class="usedin">Used in <a href="#28">28</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="30">30</a> {<strong>output html tail</strong>}</span>

<pre class="prettyprint language-python">
html_tail = ''
print(html_tail, file=output_file, end='')
</pre><span class="usedin">Used in <a href="#28">28</a>.</span></div>


<p>Weaving the source code is <strong>mostly</strong> echoing lines, keeping track of
whether we are in a code chunk (fenced code) or not. We also maintain
a code block counter.</p>

<p>After each code chunk we print a (hyperlinked) list of the chunks it
has been used at.</p>

<div class="codeblock"><span class="codeblock_name"><a id="31">31</a> {<strong>weave source</strong>}</span>

<pre class="prettyprint language-python">
reading_code_chunk = False
last_line_blank = False
chunk_name = ''
code_block_counter = 0

for line_number, line in enumerate(input_file):
    <code class="chunk_ref">@{print line if not in code chunk; process code chunk fence}</code>
    <code class="chunk_ref">@{echo code text and add closing div after closing fence}</code>

</pre><span class="usedin">Used in <a href="#28">28</a>.</span></div>


<p>Each chunk will be wrapped in a <code>div</code>; it will be preceded by a <code>span</code>
declaring the chunk name; the fences will be replaced by open and
close <code>pre</code> tags; finally, we add a span element containing the parent
chunks (i.e., chunks containing references to this one) and a closing
<code>div</code> tag.</p>

<div class="codeblock"><span class="codeblock_name"><a id="32">32</a> {<strong>print line if not in code chunk; process code chunk fence</strong>}</span>

<pre class="prettyprint language-python">
if not reading_code_chunk:
    if line.strip() == "":
        print(line,file=output_file, end='')
        last_line_blank = True
        continue
    elif last_line_blank:
        match_fence = fence_regexp.match(line)
        if match_fence:
            fence_length = match_fence.end()
            code_block_counter += 1
            <code class="chunk_ref">@{assemble `code_chunk_header`}</code>
            print(code_chunk_header, file=output_file)
            reading_code_chunk = True

        else:
            print(line,file=output_file, end='')
            last_line_blank = False
    else:
        print(line, file=output_file, end='')

    continue
</pre><span class="usedin">Used in <a href="#31">31</a>.</span></div>


<p>When we find a code chunk, we set <code>chunk_name</code> for use at the end of
the code block. This is similar to <code>@{set</code>chunk_name}`, but we set
the language of the block as well.</p>

<div class="codeblock"><span class="codeblock_name"><a id="33">33</a> {<strong>assemble `code_chunk_header`</strong>}</span>

<pre class="prettyprint language-python">
if fenced_with_language:
    j = fence_length
    while line[j] == ' ':
        j += 1
    chunk_lang_begin = j
    while line[j] != ' ':
        j += 1
    chunk_name = line[j+1:].strip()
    chunk_id = code_block_counter
    chunk_language = line[chunk_lang_begin:j]

    <code class="chunk_ref">@{set `other_blocks` as hyperlinked references to all blocks with the same name}</code>
    code_chunk_header = '<' +'div class="codeblock"><'+ 'span class="codeblock_name"><'+('a id="%d">%d<' % (chunk_id,chunk_id))+'/a> {<'+'strong>' + chunk_name + '<'+'/strong>' + other_blocks + '}<'+'/span>\n\n<'+'pre class="prettyprint language-' + chunk_language +'">'
else:
    chunk_name = line[fence_length:].strip()
    code_chunk_header = '<' +'div class="codeblock"><'+'span class="codeblock_name">{<'+'strong>' + chunk_name + '<'+'/strong>}<'+'/span>\n\n<'+'pre class="prettyprint">'
</pre><span class="usedin">Used in <a href="#32">32</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="34">34</a> {<strong>set `other_blocks` as hyperlinked references to all blocks with the same name</strong>}</span>

<pre class="prettyprint language-python">
other_blocks = ', '.join([('<'+ 'a href="#%d">%d<' + '/a>') % (b.id,b.id) for b in chunk[chunk_name].blocks if b.id != chunk_id])
if other_blocks != '':
    other_blocks = ' ' + other_blocks
</pre><span class="usedin">Used in <a href="#33">33</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="35">35</a> {<strong>echo code text and add closing div after closing fence</strong>}</span>

<pre class="prettyprint language-python">
match_fence = fence_regexp.match(line)
if match_fence and match_fence.end() == fence_length:
    seealso = ''
    if len(used_at[chunk_name]) > 0:
        seealso = '<' + 'span class="usedin">Used in ' + ', '.join([(('<' + 'a href="#%d">%d<' +'/a>') % (id,id)) for c,id,i in used_at[chunk_name]]) + '.<' + '/span>'

    
    print('<'+'/p'+'re>' + seealso +'<'+'/div>', file=output_file)


    reading_code_chunk = False
    last_line_blank = False
else:
    <code class="chunk_ref">@{output weaved code line}</code>
</pre><span class="usedin">Used in <a href="#31">31</a>.</span></div>


<p>The only syntax highlighting we do is for code chunk references.</p>

<div class="codeblock"><span class="codeblock_name"><a id="36">36</a> {<strong>output weaved code line</strong>}</span>

<pre class="prettyprint language-python">
if is_chunk_line(line):
    j = 0
    while line[j] != '@':
        j +=1
    line = ' '*j + '<' + 'code class="chunk_ref">@{' + chunk_line_name(line) + '}<' + '/code>\n'

print(line, file=output_file, end='')
</pre><span class="usedin">Used in <a href="#35">35</a>.</span></div>


<h2>Word index</h2>

<p>We keep things simple. A <strong>word</strong> is a sequence of 2 or more ascii
characters which matches the regular <code>[A-Za-z][A-Za-z0-9_]+</code>, with one
caveat: we ignore all words inside chunk references.</p>

<div class="codeblock"><span class="codeblock_name"><a id="37">37</a> {<strong>global definitions</strong> <a href="#1">1</a>, <a href="#5">5</a>, <a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>, <a href="#12">12</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>}</span>

<pre class="prettyprint language-python">
word_reg = '[A-Za-z][A-Za-z0-9_]+'
</pre><span class="usedin">Used in <a href="#2">2</a>.</span></div>


<p>The word index is a dictionary containing, for each word, the id of each code block where the word appears.</p>

<div class="codeblock"><span class="codeblock_name"><a id="38">38</a> {<strong>prepare and output word index</strong>}</span>

<pre class="prettyprint language-python">
if index:
    word_dict = {}

    <code class="chunk_ref">@{build word dictionary}</code>
    <code class="chunk_ref">@{output word index}</code>
</pre><span class="usedin">Used in <a href="#28">28</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="39">39</a> {<strong>build word dictionary</strong>}</span>

<pre class="prettyprint language-python">
for i,b in enumerate(block):
    words = []
    for l in b.lines:
        if not is_chunk_line(l):
            words += re.findall(word_reg,l)

    for w in words:
        if w not in word_dict:
            word_dict[w]  = [i]
        else:
            word_dict[w] += [i]
</pre><span class="usedin">Used in <a href="#38">38</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="40">40</a> {<strong>output word index</strong>}</span>

<pre class="prettyprint language-python">
first_letter = ' '
print("## Word index\n\n", file=output_file)
print('<' + 'ul>', file=output_file)

for w in sorted(word_dict.keys()):
    if w[0] != first_letter:
        if first_letter != ' ':
            print('<' + '/li><' +'/ul>', file=output_file)
        print(('<' +'li class="dict_letter">%c<' + 'ul>') % w[0].upper(), file=output_file)
        first_letter = w[0]

    <code class="chunk_ref">@{print cross-reference links to blocks where `w` occurs}</code>

print('<' + '/ul><' + '/ul>', file=output_file)
</pre><span class="usedin">Used in <a href="#38">38</a>.</span></div>




<div class="codeblock"><span class="codeblock_name"><a id="41">41</a> {<strong>print cross-reference links to blocks where `w` occurs</strong>}</span>

<pre class="prettyprint language-python">
links = ', '.join([('<'+ 'a href="#%d">%d<' + '/a>') % (block[j].id,block[j].id) for j in list(sorted(set(word_dict[w])))])
print(('<' +'li>%s: ' + links + '<' + '/li>') % w, file=output_file)
</pre><span class="usedin">Used in <a href="#40">40</a>.</span></div>


<h2>Word index</h2>

<ul>
<li class="dict_letter">A<ul>
<li>ArgumentParser: <a href="#5">5</a></li>
</li></ul>
<li class="dict_letter">B<ul>
<li>Block: <a href="#10">10</a>, <a href="#16">16</a></li>
</li></ul>
<li class="dict_letter">C<ul>
<li>Chunk: <a href="#9">9</a>, <a href="#16">16</a></li>
<li>Collection: <a href="#9">9</a></li>
</li></ul>
<li class="dict_letter">D<ul>
<li>DONE: <a href="#23">23</a>, <a href="#28">28</a></li>
</li></ul>
<li class="dict_letter">F<ul>
<li>False: <a href="#8">8</a>, <a href="#11">11</a>, <a href="#14">14</a>, <a href="#16">16</a>, <a href="#31">31</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
</li></ul>
<li class="dict_letter">H<ul>
<li>Hi: <a href="#2">2</a></li>
</li></ul>
<li class="dict_letter">L<ul>
<li>Lines: <a href="#10">10</a></li>
</li></ul>
<li class="dict_letter">S<ul>
<li>SystemExit: <a href="#7">7</a>, <a href="#19">19</a></li>
</li></ul>
<li class="dict_letter">T<ul>
<li>This: <a href="#1">1</a></li>
<li>True: <a href="#8">8</a>, <a href="#14">14</a>, <a href="#32">32</a></li>
</li></ul>
<li class="dict_letter">U<ul>
<li>Used: <a href="#35">35</a></li>
</li></ul>
<li class="dict_letter">V<ul>
<li>VISCONDE: <a href="#1">1</a></li>
</li></ul>
<li class="dict_letter">W<ul>
<li>Word: <a href="#40">40</a></li>
<li>Writing: <a href="#23">23</a>, <a href="#28">28</a></li>
</li></ul>
<li class="dict_letter">Z<ul>
<li>Za: <a href="#37">37</a></li>
</li></ul>
<li class="dict_letter">A<ul>
<li>action: <a href="#4">4</a></li>
<li>add_argument: <a href="#4">4</a></li>
<li>add_indent: <a href="#25">25</a>, <a href="#27">27</a></li>
<li>all: <a href="#17">17</a></li>
<li>alright: <a href="#21">21</a></li>
<li>and: <a href="#7">7</a>, <a href="#16">16</a>, <a href="#18">18</a>, <a href="#27">27</a>, <a href="#35">35</a></li>
<li>any: <a href="#21">21</a></li>
<li>argparse: <a href="#5">5</a>, <a href="#6">6</a></li>
<li>args: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>as: <a href="#11">11</a>, <a href="#23">23</a>, <a href="#28">28</a></li>
<li>aux: <a href="#27">27</a></li>
</li></ul>
<li class="dict_letter">B<ul>
<li>banner: <a href="#1">1</a>, <a href="#2">2</a></li>
<li>be: <a href="#26">26</a></li>
<li>blk: <a href="#18">18</a>, <a href="#20">20</a>, <a href="#23">23</a></li>
<li>block: <a href="#10">10</a>, <a href="#16">16</a>, <a href="#17">17</a>, <a href="#39">39</a>, <a href="#41">41</a></li>
<li>block_counter: <a href="#10">10</a></li>
<li>block_lines: <a href="#10">10</a>, <a href="#11">11</a>, <a href="#14">14</a>, <a href="#16">16</a></li>
<li>blocks: <a href="#9">9</a>, <a href="#16">16</a>, <a href="#17">17</a>, <a href="#20">20</a>, <a href="#23">23</a>, <a href="#25">25</a>, <a href="#34">34</a></li>
<li>buffer: <a href="#23">23</a>, <a href="#24">24</a>, <a href="#25">25</a></li>
</li></ul>
<li class="dict_letter">C<ul>
<li>cannot: <a href="#21">21</a></li>
<li>chk: <a href="#20">20</a></li>
<li>chosen: <a href="#21">21</a></li>
<li>chunk: <a href="#4">4</a>, <a href="#16">16</a>, <a href="#17">17</a>, <a href="#19">19</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#23">23</a>, <a href="#24">24</a>, <a href="#25">25</a>, <a href="#26">26</a>, <a href="#34">34</a></li>
<li>chunk_id: <a href="#33">33</a>, <a href="#34">34</a></li>
<li>chunk_lang_begin: <a href="#33">33</a></li>
<li>chunk_language: <a href="#33">33</a></li>
<li>chunk_line: <a href="#14">14</a>, <a href="#16">16</a></li>
<li>chunk_line_name: <a href="#24">24</a>, <a href="#27">27</a>, <a href="#36">36</a></li>
<li>chunk_name: <a href="#11">11</a>, <a href="#15">15</a>, <a href="#16">16</a>, <a href="#24">24</a>, <a href="#25">25</a>, <a href="#26">26</a>, <a href="#31">31</a>, <a href="#33">33</a>, <a href="#34">34</a>, <a href="#35">35</a></li>
<li>chunk_ref: <a href="#36">36</a></li>
<li>chunks: <a href="#17">17</a>, <a href="#19">19</a>, <a href="#21">21</a></li>
<li>chunks_of: <a href="#20">20</a>, <a href="#22">22</a></li>
<li>class: <a href="#9">9</a>, <a href="#10">10</a>, <a href="#33">33</a>, <a href="#35">35</a>, <a href="#36">36</a>, <a href="#40">40</a></li>
<li>code: <a href="#10">10</a>, <a href="#17">17</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#36">36</a></li>
<li>code_block_counter: <a href="#31">31</a>, <a href="#32">32</a>, <a href="#33">33</a></li>
<li>code_chunk_header: <a href="#32">32</a>, <a href="#33">33</a></li>
<li>codeblock: <a href="#33">33</a></li>
<li>codeblock_name: <a href="#33">33</a></li>
<li>compile: <a href="#12">12</a>, <a href="#25">25</a></li>
<li>continue: <a href="#14">14</a>, <a href="#32">32</a></li>
<li>contradictory: <a href="#7">7</a></li>
</li></ul>
<li class="dict_letter">D<ul>
<li>def: <a href="#9">9</a>, <a href="#10">10</a>, <a href="#22">22</a>, <a href="#27">27</a></li>
<li>default: <a href="#4">4</a></li>
<li>dict: <a href="#20">20</a></li>
<li>dict_letter: <a href="#40">40</a></li>
<li>div: <a href="#33">33</a>, <a href="#35">35</a></li>
<li>do: <a href="#4">4</a></li>
</li></ul>
<li class="dict_letter">E<ul>
<li>elif: <a href="#14">14</a>, <a href="#21">21</a>, <a href="#32">32</a></li>
<li>else: <a href="#14">14</a>, <a href="#16">16</a>, <a href="#18">18</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#24">24</a>, <a href="#32">32</a>, <a href="#33">33</a>, <a href="#35">35</a>, <a href="#39">39</a></li>
<li>end: <a href="#14">14</a>, <a href="#16">16</a>, <a href="#23">23</a>, <a href="#24">24</a>, <a href="#25">25</a>, <a href="#28">28</a>, <a href="#29">29</a>, <a href="#30">30</a>, <a href="#32">32</a>, <a href="#35">35</a>, <a href="#36">36</a></li>
<li>enumerate: <a href="#11">11</a>, <a href="#20">20</a>, <a href="#31">31</a>, <a href="#39">39</a></li>
<li>error: <a href="#7">7</a>, <a href="#19">19</a></li>
</li></ul>
<li class="dict_letter">F<ul>
<li>fence: <a href="#4">4</a></li>
<li>fence_length: <a href="#14">14</a>, <a href="#15">15</a>, <a href="#16">16</a>, <a href="#32">32</a>, <a href="#33">33</a>, <a href="#35">35</a></li>
<li>fence_regexp: <a href="#12">12</a>, <a href="#14">14</a>, <a href="#16">16</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
<li>fenced_with_language: <a href="#7">7</a>, <a href="#8">8</a>, <a href="#15">15</a>, <a href="#33">33</a></li>
<li>fencedwithlanguage: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>file: <a href="#4">4</a>, <a href="#7">7</a>, <a href="#8">8</a>, <a href="#11">11</a>, <a href="#23">23</a>, <a href="#24">24</a>, <a href="#28">28</a>, <a href="#29">29</a>, <a href="#30">30</a>, <a href="#32">32</a>, <a href="#35">35</a>, <a href="#36">36</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
<li>find: <a href="#21">21</a></li>
<li>findall: <a href="#39">39</a></li>
<li>first: <a href="#4">4</a></li>
<li>first_letter: <a href="#40">40</a></li>
<li>flag: <a href="#7">7</a></li>
<li>flags: <a href="#7">7</a></li>
<li>for: <a href="#11">11</a>, <a href="#18">18</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#22">22</a>, <a href="#23">23</a>, <a href="#25">25</a>, <a href="#27">27</a>, <a href="#31">31</a>, <a href="#34">34</a>, <a href="#35">35</a>, <a href="#39">39</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
</li></ul>
<li class="dict_letter">G<ul>
<li>generate: <a href="#4">4</a></li>
</li></ul>
<li class="dict_letter">H<ul>
<li>help: <a href="#4">4</a></li>
<li>href: <a href="#34">34</a>, <a href="#35">35</a>, <a href="#41">41</a></li>
<li>html_header: <a href="#29">29</a></li>
<li>html_tail: <a href="#30">30</a></li>
</li></ul>
<li class="dict_letter">I<ul>
<li>id: <a href="#10">10</a>, <a href="#20">20</a>, <a href="#33">33</a>, <a href="#34">34</a>, <a href="#35">35</a>, <a href="#41">41</a></li>
<li>if: <a href="#7">7</a>, <a href="#14">14</a>, <a href="#15">15</a>, <a href="#16">16</a>, <a href="#18">18</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#22">22</a>, <a href="#24">24</a>, <a href="#32">32</a>, <a href="#33">33</a>, <a href="#34">34</a>, <a href="#35">35</a>, <a href="#36">36</a>, <a href="#38">38</a>, <a href="#39">39</a>, <a href="#40">40</a></li>
<li>import: <a href="#6">6</a>, <a href="#13">13</a></li>
<li>in: <a href="#11">11</a>, <a href="#16">16</a>, <a href="#18">18</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#22">22</a>, <a href="#23">23</a>, <a href="#24">24</a>, <a href="#25">25</a>, <a href="#27">27</a>, <a href="#31">31</a>, <a href="#34">34</a>, <a href="#35">35</a>, <a href="#39">39</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
<li>ind_lns: <a href="#25">25</a></li>
<li>indent: <a href="#25">25</a></li>
<li>indent_amount: <a href="#27">27</a></li>
<li>index: <a href="#4">4</a>, <a href="#7">7</a>, <a href="#8">8</a>, <a href="#38">38</a>, <a href="#40">40</a></li>
<li>init__: <a href="#9">9</a>, <a href="#10">10</a></li>
<li>input: <a href="#7">7</a></li>
<li>input_file: <a href="#11">11</a>, <a href="#28">28</a>, <a href="#31">31</a></li>
<li>insert: <a href="#24">24</a></li>
<li>is: <a href="#1">1</a>, <a href="#4">4</a></li>
<li>is_chunk_line: <a href="#22">22</a>, <a href="#24">24</a>, <a href="#27">27</a>, <a href="#36">36</a>, <a href="#39">39</a></li>
<li>it: <a href="#21">21</a></li>
<li>items: <a href="#20">20</a></li>
</li></ul>
<li class="dict_letter">J<ul>
<li>join: <a href="#19">19</a>, <a href="#21">21</a>, <a href="#34">34</a>, <a href="#35">35</a>, <a href="#41">41</a></li>
</li></ul>
<li class="dict_letter">K<ul>
<li>kept: <a href="#26">26</a></li>
<li>keys: <a href="#40">40</a></li>
</li></ul>
<li class="dict_letter">L<ul>
<li>language: <a href="#4">4</a>, <a href="#33">33</a></li>
<li>last_line_blank: <a href="#11">11</a>, <a href="#14">14</a>, <a href="#16">16</a>, <a href="#31">31</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
<li>len: <a href="#18">18</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#23">23</a>, <a href="#35">35</a></li>
<li>li: <a href="#40">40</a>, <a href="#41">41</a></li>
<li>line: <a href="#11">11</a>, <a href="#14">14</a>, <a href="#15">15</a>, <a href="#16">16</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#31">31</a>, <a href="#32">32</a>, <a href="#33">33</a>, <a href="#35">35</a>, <a href="#36">36</a></li>
<li>line_number: <a href="#10">10</a>, <a href="#11">11</a>, <a href="#14">14</a>, <a href="#31">31</a></li>
<li>lines: <a href="#10">10</a>, <a href="#11">11</a>, <a href="#20">20</a>, <a href="#23">23</a>, <a href="#25">25</a>, <a href="#39">39</a></li>
<li>links: <a href="#41">41</a></li>
<li>list: <a href="#11">11</a>, <a href="#19">19</a>, <a href="#41">41</a></li>
<li>literate: <a href="#4">4</a></li>
</li></ul>
<li class="dict_letter">M<ul>
<li>many: <a href="#19">19</a></li>
<li>many_outpus: <a href="#7">7</a>, <a href="#8">8</a>, <a href="#18">18</a></li>
<li>manyoutputs: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>match: <a href="#14">14</a>, <a href="#16">16</a>, <a href="#25">25</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
<li>match_fence: <a href="#14">14</a>, <a href="#16">16</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
<li>md: <a href="#28">28</a></li>
</li></ul>
<li class="dict_letter">N<ul>
<li>name: <a href="#4">4</a>, <a href="#9">9</a></li>
<li>new_block: <a href="#16">16</a></li>
<li>no: <a href="#7">7</a>, <a href="#21">21</a></li>
<li>nofencedwithlanguage: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>noindex: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>nomanyoutputs: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>not: <a href="#4">4</a>, <a href="#7">7</a>, <a href="#14">14</a>, <a href="#16">16</a>, <a href="#18">18</a>, <a href="#20">20</a>, <a href="#24">24</a>, <a href="#32">32</a>, <a href="#39">39</a></li>
<li>notangle: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>noweave: <a href="#4">4</a>, <a href="#7">7</a></li>
</li></ul>
<li class="dict_letter">O<ul>
<li>of: <a href="#9">9</a>, <a href="#10">10</a>, <a href="#11">11</a></li>
<li>on: <a href="#4">4</a></li>
<li>one: <a href="#4">4</a></li>
<li>open: <a href="#11">11</a>, <a href="#23">23</a>, <a href="#28">28</a></li>
<li>opening: <a href="#4">4</a></li>
<li>option: <a href="#21">21</a></li>
<li>other_blocks: <a href="#33">33</a>, <a href="#34">34</a></li>
<li>out_filename: <a href="#28">28</a></li>
<li>output: <a href="#4">4</a>, <a href="#23">23</a>, <a href="#24">24</a></li>
<li>output_file: <a href="#28">28</a>, <a href="#29">29</a>, <a href="#30">30</a>, <a href="#32">32</a>, <a href="#35">35</a>, <a href="#36">36</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
<li>outputs: <a href="#4">4</a></li>
</li></ul>
<li class="dict_letter">P<ul>
<li>parents: <a href="#20">20</a></li>
<li>parse_args: <a href="#4">4</a></li>
<li>parser: <a href="#4">4</a>, <a href="#5">5</a></li>
<li>per: <a href="#4">4</a></li>
<li>pre: <a href="#33">33</a></li>
<li>prettyprint: <a href="#33">33</a></li>
<li>print: <a href="#2">2</a>, <a href="#20">20</a>, <a href="#21">21</a>, <a href="#23">23</a>, <a href="#24">24</a>, <a href="#26">26</a>, <a href="#28">28</a>, <a href="#29">29</a>, <a href="#30">30</a>, <a href="#32">32</a>, <a href="#35">35</a>, <a href="#36">36</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
<li>produce: <a href="#4">4</a></li>
</li></ul>
<li class="dict_letter">R<ul>
<li>raise: <a href="#7">7</a>, <a href="#19">19</a></li>
<li>re: <a href="#12">12</a>, <a href="#13">13</a>, <a href="#25">25</a>, <a href="#35">35</a>, <a href="#39">39</a></li>
<li>reading_code_chunk: <a href="#11">11</a>, <a href="#14">14</a>, <a href="#16">16</a>, <a href="#31">31</a>, <a href="#32">32</a>, <a href="#35">35</a></li>
<li>reference: <a href="#24">24</a>, <a href="#26">26</a></li>
<li>rest: <a href="#4">4</a></li>
<li>return: <a href="#22">22</a>, <a href="#27">27</a></li>
<li>root: <a href="#4">4</a>, <a href="#19">19</a>, <a href="#21">21</a></li>
<li>root_chunks: <a href="#18">18</a>, <a href="#19">19</a>, <a href="#20">20</a>, <a href="#21">21</a></li>
</li></ul>
<li class="dict_letter">S<ul>
<li>same: <a href="#9">9</a></li>
<li>seealso: <a href="#35">35</a></li>
<li>self: <a href="#9">9</a>, <a href="#10">10</a></li>
<li>set: <a href="#41">41</a></li>
<li>sorted: <a href="#40">40</a>, <a href="#41">41</a></li>
<li>source: <a href="#4">4</a></li>
<li>span: <a href="#33">33</a>, <a href="#35">35</a></li>
<li>start: <a href="#10">10</a></li>
<li>store_true: <a href="#4">4</a></li>
<li>strip: <a href="#14">14</a>, <a href="#15">15</a>, <a href="#22">22</a>, <a href="#27">27</a>, <a href="#32">32</a>, <a href="#33">33</a></li>
<li>strong: <a href="#33">33</a></li>
</li></ul>
<li class="dict_letter">T<ul>
<li>tangle: <a href="#4">4</a>, <a href="#7">7</a>, <a href="#8">8</a>, <a href="#18">18</a>, <a href="#21">21</a></li>
<li>tangled: <a href="#4">4</a></li>
<li>text: <a href="#4">4</a></li>
<li>the: <a href="#4">4</a></li>
<li>todo: <a href="#21">21</a></li>
<li>too: <a href="#19">19</a></li>
</li></ul>
<li class="dict_letter">U<ul>
<li>ul: <a href="#40">40</a></li>
<li>undefined: <a href="#26">26</a></li>
<li>upper: <a href="#40">40</a></li>
<li>used_at: <a href="#20">20</a>, <a href="#35">35</a></li>
<li>usedin: <a href="#35">35</a></li>
</li></ul>
<li class="dict_letter">V<ul>
<li>verbatim: <a href="#24">24</a>, <a href="#26">26</a></li>
<li>version: <a href="#1">1</a></li>
</li></ul>
<li class="dict_letter">W<ul>
<li>warning: <a href="#21">21</a>, <a href="#26">26</a></li>
<li>was: <a href="#21">21</a></li>
<li>weave: <a href="#4">4</a>, <a href="#7">7</a></li>
<li>weaved: <a href="#4">4</a></li>
<li>while: <a href="#15">15</a>, <a href="#23">23</a>, <a href="#33">33</a>, <a href="#36">36</a></li>
<li>will: <a href="#26">26</a></li>
<li>with: <a href="#9">9</a>, <a href="#11">11</a>, <a href="#23">23</a>, <a href="#28">28</a></li>
<li>word: <a href="#4">4</a></li>
<li>word_dict: <a href="#38">38</a>, <a href="#39">39</a>, <a href="#40">40</a>, <a href="#41">41</a></li>
<li>word_reg: <a href="#37">37</a>, <a href="#39">39</a></li>
<li>words: <a href="#39">39</a></li>
</li></ul>
<li class="dict_letter">Z<ul>
<li>z0: <a href="#37">37</a></li>
</ul></ul>

</body></html>
