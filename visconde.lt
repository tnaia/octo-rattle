# Basic literate tool in python

## Introduction

This is a rough tool for literate programming, built along the lines 
of the CWEB program of [Knuth and Levy](https://cs.stanford.edu/~knuth/lp.html). 
Our syntax follows that of [Literate](https://github.com/zyedidia/Literate/). 
We only implement a subset of these programs' functionality.

More precisely, this program is a minimal "tangler" which operates on a single
input file, under the restriction that any chunk reference `@{chunk name}` lies 
on a line  of its own (so, no comments are allowed in a line that references
a chunk, and a chunk name cannot contain line breaks).

Here is the program outline.

``` visconde.py
@{imports}

@{global definitions}

@{parse arguments}
@{process input file}
@{output tangled sources}
```

The line below should be updated whenever this program is changed.

``` global definitions
banner = "This is COB version 0.1.2."
```

## Arguments


For now, the only argument to the program is the target file.

``` parse arguments
file = sys.argv[-1]
```

``` imports
import sys
```

``` global definitions
file = ""
```


## Storing chunks

When tangling, we only care about code chunks, and all of these must be named.


``` process input file
print(banner) # Hi!

with open(file, 'r') as input_file:
    reading_code_chunk = False
    last_line_blank = False
    chunk_name = ''
    chunk_text = [] # list of lines
    for line_number, line in enumerate(input_file):
        @{continue if not in code chunk; store `chunk_name` and set `reading_code_chunk`}
    
        @{add line to `chunk_text` or complete and store chunk}
```

Every code chunk is preceeded by a blank line (i.e., a line with only whitespace).
The first line of a code chunk begins with three or more backticks (` ``` `), 
followed by the chunk name. The last line of a code chunk contains only backticks,
(as many as there were at the chunk's first line).

``` global definitions
fence_regexp = re.compile('```+')
```

``` imports
import re
```

Note that each branch inside the first `if` statement below 
ends with `continue`, so we only proceed reach `@{add line to...}`
when `reading_code_chunk == True`.

``` continue if not in code chunk; store `chunk_name` and set `reading_code_chunk`
if not reading_code_chunk:
    if line.strip() == "":
        last_line_blank = True
        continue
    elif last_line_blank:
        match_fence = fence_regexp.match(line) # at least 3 backticks
        if match_fence:
            fence_length = match_fence.end()
            chunk_name = line[fence_length:].strip()
            chunk_line = line_number
            chunk_text = []
            reading_code_chunk = True
        else:
            last_line_blank = False

    continue
```

We store the code of chunks in a dictionary `chunk`.
Each dictionary entry is a list of tuples `(line_num, code)` containing 
- the line number of the first line of the chunk, and
- the code in the chunk.

``` add line to `chunk_text` or complete and store chunk
match_fence = fence_regexp.match(line) # at least 3 backticks
if match_fence and match_fence.end() == fence_length:
    if chunk_name not in chunk:
        chunk[chunk_name] = []
    chunk[chunk_name] += [(chunk_line+1, chunk_text)]
    reading_code_chunk = False
    last_line_blank = False
else:
    chunk_text += [line]
```

``` global definitions
chunk = {}
```

## From chunks to files

At this point, all code is loaded in the `chunk` dictionary.
If chunk `'blabla'` isn't referenced by any other chunk, 
we create a file whose contents will be `chunk['blabla']`,
with lines of the form `@{blabla}` replaced by the contents 
of the chunk `'blabla'`.

The first step is to identify which chunks are *roots*, 
that is, which chunks will be turned to files. 

``` output tangled sources
used_at = dict()

@{build list of `root_chunks`}

for blk in root_chunks:
    @{write `blk` to a file}
```

In order to locate 'root chunks', we use a dictionary `used_at`,
so (for instance) `used_at['global defintions']` is a list of
`chunk_name`s which contain `@{global definitions}` in their
text.

``` build list of `root_chunks`
for blk in chunk:
    if blk not in used_at:
        used_at[blk] = []
    for l,b in chunk[blk]:
        for chk in chunk_in_references(b):
            if chk not in used_at:
                used_at[chk] = [blk]
            else:
                used_at[chk] += [blk]

# expansion_order = [blk for blk, parents in sorted(used_at.items(), key=lambda t: len(t[1]),reverse=True)]
root_chunks = [blk for blk, parents in used_at.items() if len(parents) == 0]

```

``` global definitions
def chunk_in_references(chunk_text):
    references = []
    for line in chunk_text:
        line = line.strip() 
        # here we would remove comments in the line as well
        if is_chunk_line(line):
            references += [line[2:-1].strip()]

    return references
```

We finally handle writing each root chunk to a file.
The next lines to be output are stored in a buffer.
More precisely, `buffer[i]` is the next we'll output,
which we first expand (when it is a chunk reference).

``` write `blk` to a file
print("Writing file %s... " % blk,end='')
with open(blk, 'w') as output:
    buffer = [l for c in chunk[blk] for l in c[1]]
    i = 0
    while i < len(buffer):
        if is_chunk_line(buffer[i]):
            @{add contents of chunk to buffer}
        else:
            print(buffer[i], file=output, end='')
            i += 1
    
print("[ DONE ]")
```

``` add contents of chunk to buffer
the_chunk_name = chunk_line_name(buffer[i])
if the_chunk_name not in chunk:       # do we know what to insert in place of line?
    @{warn of missing chunk}
else:
    indentation = re.compile(' *').match(buffer[i]).end()
    indented_lines = [x for l,c in  chunk[the_chunk_name] for x in indent_code(indentation, c)]
    buffer = indented_lines + buffer[i+1:]
    i = 0
```

``` warn of missing chunk
print("! warning: missing text for chunk: %s" % the_chunk_name)
print(buffer[i], file=output, end='')
i += 1
```

``` global definitions
def is_chunk_line(l):
    aux = l.strip()
    return aux and (aux[0:2] == '@{' and aux[-1] == '}')

def chunk_line_name(line):
    return line.strip()[2:-1].strip()

def indent_code(indentation, code):
    return [' '*indentation + line for line in code]
```


